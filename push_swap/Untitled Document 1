------------------------
#COMBO/*_ALGO
/* This function iterates through each element in stack_a and calculates
	the minimum number of operations required to bring each element from
	stack_a to stack_b using different rotation methods, and returns the
	overall minimum number of operations among all elements in stack_a */
int	ft_combo_ab(int nbr, t_stack *stack_a, t_stack *stack_b, t_vals *vals)
{
	t_stack	*tmp;
	int		best;

	tmp = stack_a;
	best = ft_ops_rr_ab(nbr, stack_a, stack_b, vals);
	while (tmp)
	{
		if (best > ft_ops_r_ab(tmp->nbr, stack_a, stack_b, vals))
			best = ft_ops_r_ab(tmp->nbr, stack_a, stack_b, vals);
		if (best > ft_ops_rr_ab(tmp->nbr, stack_a, stack_b, vals))
			best = ft_ops_rr_ab(tmp->nbr, stack_a, stack_b, vals);
		if (best > ft_ops_rrbra_ab(tmp->nbr, stack_a, stack_b, vals))
			best = ft_ops_rrbra_ab(tmp->nbr, stack_a, stack_b, vals);
		if (best > ft_ops_rrarb_ab(tmp->nbr, stack_a, stack_b, vals))
			best = ft_ops_rrarb_ab(tmp->nbr, stack_a, stack_b, vals);
		tmp = tmp->next;
	}
	return (best);
}

/* This function iterates through each element in stack_b and calculates
	the minimum number of operations required to bring each element from
	stack_b to stack_a using different rotation methods, and returns the
	overall minimum number of operations among all elements in stack_b */
int	ft_combo_ba(int nbr, t_stack *stack_b, t_stack *stack_a, t_vals *vals)
{
	t_stack	*tmp;
	int		best;

	tmp = stack_b;
	best = ft_ops_rr_ba(nbr, stack_a, stack_b, vals);
	while (tmp)
	{
		if (best > ft_ops_r_ba(nbr, stack_a, stack_b, vals))
			best = ft_ops_r_ba(nbr, stack_a, stack_b, vals);
		if (best > ft_ops_rr_ba(nbr, stack_a, stack_b, vals))
			best = ft_ops_rr_ba(nbr, stack_a, stack_b, vals);
		if (best > ft_ops_rrbra_ba(nbr, stack_a, stack_b, vals))
			best = ft_ops_rrbra_ba(nbr, stack_a, stack_b, vals);
		if (best > ft_ops_rrarb_ba(nbr, stack_a, stack_b, vals))
			best = ft_ops_rrarb_ba(nbr, stack_a, stack_b, vals);
		tmp = tmp->next;
	}
	return (best);
}
------------------------
#MOVES_ALGO
/* All these functions perform a series of operations on the two stacks to
	move a value nbr from one stack to the other. They use stack operations
	to achieve the desired order of elements in the stacks */

int	ft_apply_r_ab(int nbr, t_stack **stack_a, t_stack **stack_b, t_vals *vals)
{
	while ((*stack_a)->nbr != nbr && ft_finddst_ab(nbr, *stack_b, vals) > 0)
		ft_rr(stack_a, stack_b);
	while ((*stack_a)->nbr != nbr)
		ft_rotate(stack_a, 'a');
	while (ft_finddst_ab(nbr, *stack_b, vals) > 0)
		ft_rotate(stack_b, 'b');
	ft_push(stack_a, stack_b, 'b');
	return (-1);
}

int	ft_apply_rr_ab(int nbr, t_stack **stack_a, t_stack **stack_b, t_vals *vals)
{
	if (ft_finddst_ab(nbr, *stack_b, vals) < 0)
		return (0);
	while ((*stack_a)->nbr != nbr && ft_finddst_ab(nbr, *stack_b, vals) > 0)
		ft_rrr(stack_a, stack_b);
	while ((*stack_a)->nbr != nbr)
		ft_reverserotate(stack_a, 'a');
	while (ft_finddst_ab(nbr, *stack_b, vals) > 0)
		ft_reverserotate(stack_b, 'b');
	ft_push(stack_a, stack_b, 'b');
	return (-1);
}

int	ft_apply_rrarb_ab(int nbr, t_stack **stack_a, t_stack **stack_b, t_vals *vals)
{
	while ((*stack_a)->nbr != nbr)
		ft_reverserotate(stack_a, 'a');
	while (ft_finddst_ab(nbr, *stack_b, vals) > 0)
		ft_rotate(stack_b, 'b');
	ft_push(stack_a, stack_b, 'b');
	return (-1);
}

int	ft_apply_rrbra_ab(int nbr, t_stack **stack_a, t_stack **stack_b, t_vals *vals)
{
	while ((*stack_a)->nbr != nbr)
		ft_rotate(stack_b, 'a');
	while (ft_finddst_ab(nbr, *stack_b, vals) > 0)
		ft_reverserotate(stack_a, 'b');
	ft_push(stack_a, stack_b, 'b');
	return (-1);
}
------------------------
#FIND_ALGO
This function finds the current position of a number in the stack */
ok
int	ft_findidx(int nbr, t_stack *stack)
{
	int	idx;

	idx = 0;
	while (stack && stack->nbr != nbr)
	{
		idx++;
		stack = stack->next;
	}
	return (idx);
}

ok
/* This function handles different cases based on the relationship between
	nbr and the top, last, minimum, and maximum values of stack_b and,
	depending on the case, it determines whether rotations are required
	or not and calculates the correct position in stack_b */
int	ft_finddst_ab(int nbr, t_stack *stack_b, t_vals *vals)
{
	int	dst;

	dst = 1;
	if (nbr > stack_b->nbr && nbr < ft_stacklast(stack_b)->nbr)
		dst = 0;
	else if (nbr < vals->min_b || nbr > vals->max_b)
		dst = ft_findidx(vals->max_b, stack_b);
	else
	{
		while (nbr > stack_b->nbr || nbr < stack_b->next->nbr)
		{
			dst++;
			stack_b = stack_b->next;
		}
	}
	return (dst);
}

ok
/* This function handles different cases based on the relationship between
	nbr and the top, last, minimum, and maximum values of stack_a and,
	depending on the case, it determines whether rotations are required
	or not and calculates the correct position in stack_a */
int	ft_finddst_ba(int nbr, t_stack *stack_a, t_vals *vals)
{
	int	dst;

	dst = 1;
	if (nbr > stack_a->nbr && nbr < ft_stacklast(stack_a)->nbr)
		dst = 0;
	else if (nbr < vals->min_a || nbr > vals->max_a)
		dst = ft_findidx(vals->min_a, stack_a);
	else
	{
		while (nbr < stack_a->nbr || nbr > stack_a->next->nbr)
		{
			dst++;
			stack_a = stack_a->next;
		}
	}
	return (dst);
}

ok
/* This functoin finds the smallest number in the stack */
int ft_findmin(t_stack *stack)
{
    int i;

	if (!stack)
		return (0);
    i = stack->nbr;
    while (stack)
    {
        if (i > stack->nbr)
            i = stack->nbr;
        stack = stack->next;    
    }   
    return (i);
}

ok
/* This function finds the biggest number in the stack */
int ft_findmax(t_stack *stack)
{
    int i;

	if (!stack)
		return (0);
    i = stack->nbr;
    while (stack)
    {
        if (i < stack->nbr)
            i = stack->nbr;
        stack = stack->next;
    }
    return (i);
}

------------------------
#SORT ALGORITMO
Funzione che sceglie la combo piu conveniente basandosi sulla comparazione fra mosse migliori e risultati delle varie operazioni; dopo applica l'operazione indicata con ft_apply* per modificare gli stack in modo corretto

void	ft_apply_combo_ab(int nbr, t_stack **stack_a, t_stack **stack_b, t_vals *vals)
{
	t_stack	*tmp;
	int		best;

	tmp = *stack_a;
	best = ft_ops_rr_ab(nbr, *stack_a, *stack_b, vals);
	while (tmp)
	{
		if (best == ft_ops_r_ab(tmp->nbr, *stack_a, *stack_b, vals))
			ft_apply_r_ab(tmp->nbr, stack_a, stack_b, vals);
		else if (best == ft_ops_rr_ab(tmp->nbr, *stack_a, *stack_b, vals))
			ft_apply_rr_ab(tmp->nbr, stack_a, stack_b, vals);
		else if (best == ft_ops_rrarb_ab(tmp->nbr, *stack_a, *stack_b, vals))
			ft_apply_rrarb_ab(tmp->nbr, stack_a, stack_b, vals);
		else if (best == ft_ops_rrbra_ab(tmp->nbr, *stack_a, *stack_b, vals))
			ft_apply_rrbra_ab(tmp->nbr, stack_a, stack_b, vals);
		tmp = tmp->next;
	}
}

void	ft_apply_combo_ba(int nbr, t_stack **stack_b, t_stack **stack_a, t_vals *vals)
{
	t_stack	*tmp;
	int		best;

	tmp = *stack_b;
	best = ft_ops_rr_ba(nbr, *stack_b, *stack_a, vals);
	while (tmp)
	{
		if (best == ft_ops_r_ba(tmp->nbr, *stack_a, *stack_b, vals))
			ft_apply_r_ba(tmp->nbr, stack_a, stack_b, vals);
		else if (best == ft_ops_rr_ba(tmp->nbr, *stack_a, *stack_b, vals))
			ft_apply_rr_ba(tmp->nbr, stack_a, stack_b, vals);
		else if (best == ft_ops_rrarb_ba(tmp->nbr, *stack_a, *stack_b, vals))
			ft_apply_rrarb_ba(tmp->nbr, stack_a, stack_b, vals);
		else if (best == ft_ops_rrbra_ba(tmp->nbr, *stack_a, *stack_b, vals))
			ft_apply_rrbra_ba(tmp->nbr, stack_a, stack_b, vals);
		tmp = tmp->next;
	}
}

------------------------
#OPERAZIONI ALGORITMO AB
#Funzione che clacola il numero di rotazioni richieste per per portare n nella sua posizione corretta nei due stack; ritorna il numero minimo di rotazioni necessarie 

int	ft_ops_r_ab(int nbr, t_stack *stack_a, t_stack *stack_b, t_vals *vals)
{
	int	ops;

	ops = ft_finddst_ab(nbr, stack_a, stack_b, vals);
	if (ops < ft_findidx(nbr, stack_a))
		ops = ft_findidx(nbr, stack_a);
	return (ops);
}


#Funzione che clacola il numero di reverse rotation richieste per per portare n nella sua posizione corretta nei due stack; cpara il numero di reverse rotations necerrarie per ognuno dei due stack; ritorna il numero minimo di revers rotations necessarie fra i due stack

int	ft_ops_rr_ab(int nbr, t_stack *stack_a, t_stack *stack_b, t_vals *vals)
{
	int	ops;

	ops = 0;
	ft_stackprint(stack_a);
	ft_stackprint(stack_b);
	if (ft_finddst_ab(nbr, stack_a, stack_b, vals))
	{
		ft_stackprint(stack_a);
		ft_stackprint(stack_b);
		// Qui esegue ft_newmax() e poi stack_a diventa 3 2 1, mentre stack_b rimane 2 1
		ops = ft_stacksize(stack_b) - ft_finddst_ab(nbr, stack_a, stack_b, vals);
	}
	if ((ops < (ft_stacksize(stack_a) - ft_findidx(nbr, stack_a)))
		&& ft_findidx(nbr, stack_a))
		ops = ft_stacksize(stack_a) - ft_findidx(nbr, stack_a);
	return (ops);
}

#Funzione che calcola il numero totale di reverse rotations per ognuno dei due stack necessarie per portare n nella sua posizione corretta nei due stack; considera l'indirizzo attuale di n nello stack a e la posizione in cui n dovrebbe essere inserito nello stack b. Sommando questi due valori si ricava il totale delle rotazioni necessarie per entrambi gli stack.

int	ft_ops_rrarb_ab(int nbr, t_stack *stack_a, t_stack *stack_b, t_vals *vals)
{
	int	ops;

	ops = 0;
	if (ft_findidx(nbr, stack_a))
		ops = ft_stacksize(stack_a) - ft_findidx(nbr, stack_a);
	ops = ft_finddst_ab(nbr, stack_a, stack_b, vals) + ops;
	return (ops);
}

#Funzione che clacola il numero totale di reverse rotations per ognuno dei due stack necessarie per portare n nella sua positione corretta nei due stack; considera l'indirizzo attuale di n nello stack b e la posizione in cui n dovrebbe essere inserito nello stack a. Sommando questi due valori si ricava il totale delle rotazioni necessarie per entrambi gli stack.

int	ft_ops_rrbra_ab(int nbr, t_stack *stack_a, t_stack *stack_b, t_vals *vals)
{
	int	ops;

	ops = 0;
	if (ft_finddst_ab(nbr, stack_a, stack_b, vals))
		ops = ft_stacksize(stack_b) - ft_finddst_ab(nbr, stack_a, stack_b, vals);
	ops = ft_findidx(nbr, stack_a) + ops;
	return (ops);
}
------------------------
#OPERAZIONI ALGORITMO BA
/* This function calculates the number of rotations required to bring the
	value nbr to its correct position in the two stacks, and returns the
	minimum number of rotations needed between them */
int	ft_ops_r_ba(int nbr, t_stack *stack_a, t_stack *stack_b, t_vals *vals)
{
	int	ops;

	ops = ft_finddst_ba(nbr, stack_a, vals);
	if (ops < ft_findidx(nbr, stack_b))
		ops = ft_findidx(nbr, stack_b);
	return (ops);
}

/* This function calculates the number of reverse rotations required to
	bring the value nbr to its correct position in the two stacks. It
	compares the number of reverse rotations needed for stack_a and
	stack_b, and returns the minimum number of reverse rotations
	needed between the two stacks */
int	ft_ops_rr_ba(int nbr, t_stack *stack_a, t_stack *stack_b, t_vals *vals)
{
	int	ops;

	ops = 0;
	if (ft_finddst_ba(nbr, stack_a, vals))
		ops = ft_stacksize(stack_a) - ft_finddst_ba(nbr, stack_a, vals);
	if ((ops < (ft_stacksize(stack_a) - ft_findidx(nbr, stack_b)))
		&& ft_findidx(nbr, stack_b))
		ops = ft_stacksize(stack_b) - ft_findidx(nbr, stack_b);
	return (ops);
}

/* This function calculates the total number of reverse rotations for
	stack_a and rotations for stack_b required to bring the value nbr
	to its correct position in the two stacks. It considers the index
	of nbr in stack_a and the position where nbr should be inserted in
	stack_b. By summing up these values, it provides the total number of 
	rotation operations needed for both stacks */
int	ft_ops_rrarb_ba(int nbr, t_stack *stack_a, t_stack *stack_b, t_vals *vals)
{
	int	ops;

	ops = 0;
	if (ft_findidx(nbr, stack_b))
		ops = ft_stacksize(stack_b) - ft_findidx(nbr, stack_b);
	ops = ft_finddst_ba(nbr, stack_a, vals) + ops;
	return (ops);
}

/* This function calculates the total number of reverse rotations for
	stack_b and rotations for stack_a required to bring the value nbr
	to its correct position in the two stacks. It considers the position
	where nbr should be inserted in stack_b and the index of nbr in stack_a.
	By summing up these values, it provides the total number of rotations
	needed for both stacks */
int	ft_ops_rrbra_ba(int nbr, t_stack *stack_a, t_stack *stack_b, t_vals *vals)
{
	int	ops;

	ops = 0;
	if (ft_finddst_ba(nbr, stack_a, vals))
		ops = ft_stacksize(stack_a) - ft_finddst_ba(nbr, stack_a, vals);
	ops = ft_findidx(nbr, stack_b) + ops;
	return (ops);
}
